alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]

# 12345 이런식이면
# 1일때 가짓수
# 12일때 가짓수
# 123일때 가짓수 이런식으로 늘리면 될 거 같다.
# 123의 경우 생각해보면 1 + 23 또는 12 + 3이 될 수 있으니 1의경우의수 + 12의 경우의 수를 더하면 된다.
# 123 -> ABC, LC, AW  1의 가짓수(1개) + 12의 가짓수(AB, L 2가지)
# 101 -> JA 1가지
# 2번째 0에서 "" + 10 또는 1 + 0 인데 후자는 성립이 안되니 전자만 포함(1개)
# 3번째 1에서 1 + 01 또는 10 + 1 인데 01은 말이안되니 10 + 1만 인정된다.

crpt = input()
dp = [0 for _ in range(len(crpt) + 1)]

lastNum = crpt[0]
dp[0] = 1
dp[1] = 1 if crpt[0] != "0" else 0
for i in range(2, len(crpt) + 1):
    num = crpt[i - 1]
    # 현재 확인한 개수-2의 경우의수와 현재 확인한 개수-1의 경우의수를 더한다.
    if lastNum[0] != "0" and 0 < int(lastNum + num) <= 26:
        dp[i] += dp[i - 2]
    if 0 < int(num) <= 9:
        dp[i] += dp[i - 1]
    dp[i] %= 1000000
    lastNum = num
print(dp[-1])
# print(dp[-1] % 1000000) 이렇게 적은 사람도 있는데 이건 파이썬이라 가능...
# 이 문제는 가장 개수가 많은 경우가 dp값들이 피보나치를 이루는 경우가 가장 큼(전부 1로 5000자의 경우)
# 그런데 피보나치 5000번째 수는 엄청나게 큰 수라 다른언어였으면 오버플로우났음...