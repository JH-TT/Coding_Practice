def solution(scores):
    ho = scores[0]
    rank = 1
    max_ = 0
    scores = sorted(scores, key = lambda x : (-x[0], x[1])) # <- 중요 포인트
    
    for s in scores:
        if ho[0] < s[0] and ho[1] < s[1]:
            return -1
        # 인센을 받을 수 있는 경우
        if max_ <= s[1]:
            # 완호보다 합이 더 크면 순위가 더 높은 회원이 존재하니 완호의 rank가 내려간다(랭크가 내려간다는건 순위의 "숫자값"이 증가한다는 의미)
            if sum(s) > sum(ho):
                rank += 1
            max_ = s[1] # max_값 업데이트
    
    return rank

# 어떻게 정렬하냐가 중요했던 문제
# 꽤나 까다로웠던 부분이 사원끼리 둘 다 점수가 낮으면 인센티브에서 제외되는 조건이었다.
# 나는 0번 점수 기준으로 내림차순은 생각했지만, 1번점수를 오름차순으로 정렬하는건 생각하지 못했다.
# 만약 1번점수를 내림차순으로 정렬해 버리면, max_를 업데이트 하는 부분에서 0번 인덱스는 같은데 1번이 꽤 커서 이전에 max_가 업데이트 되어 다른 같은 0번점수 사원끼리 계산이 잘못되는 상황이 발생하게 된다.
# 그래서 0번 점수가 같은 사원이 있으면 1번 점수는 오름차순으로 천천히 max_값을 업데이트 하도록 구현한다.