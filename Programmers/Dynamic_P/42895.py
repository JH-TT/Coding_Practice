def solution(N, number):
    dp = []
    for i in range(1, 9): # 최솟값이 8까지.
        num = set() # 중복을 없애기 위해 집합이용.
        num.add(int(str(N)*i)) # N을 i개 이어붙인것.
        for j in range(0, i - 1):
            # 양끝인덱스에서 서로 사칙연산을 하고 num에 저장.
            for h in dp[j]:
                for k in dp[-j-1]:
                    num.add(h-k)
                    num.add(h+k)
                    num.add(h*k)
                    if k != 0:
                        num.add(h//k)
        if number in num: # 찾는 수가 num에 있으면 종료.
            return i
        dp.append(num)
    return -1 # 최솟값이 8보다 커지므로 -1 출력.

# 풀이
# 1. N을 사용해서 만들 수 있는 숫자 조합을 생성하고, 각 횟수별로 저장한다.
# 2. 만들어진 숫자 조합에 number가 있는지 확인한다.
# 3. 있다면, 그 때의 횟수를 반환한다.
# 4. 없다면, 다시 1~3 과정을 반복한다.

# 여기서 반복되는 과정, 즉 중복을 찾아 없애야 한다.

# 만약 N=3이라면,

# 1) 3을 1번 사용해서 만들 수 있는 숫자
# : 3

# 2) 3을 2번 사용해서 만들 수 있는 숫자
# : 33
# 3+3, 3-3, 3*3, 3/3

# 3) 3을 3번 사용해서 만들 수 있는 숫자
# : 333
# 33+3, 33-3, 33*3, 33/3

# 4) 3을 4번 사용해서 만들 수 있는 숫자
# : 3333
# 333+3, 333-3, 333*3, 333/3
# 33+33, 33-33, 33*33, 33/33
# (33+3)+3, (33+3)-3, (33+3)*3, (33+3)/3
# 이렇게 연산에 대입되는 숫자들이 반복되는 것을 확인할 수 있다.
# [출처](https://blog.naver.com/chr11200/222413532614)
