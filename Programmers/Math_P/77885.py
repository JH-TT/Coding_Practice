def solution2(numbers):
    answer = []
    for n in numbers:
        binary = bin(n)[2:][::-1]
        idx = 0
        while idx < len(binary):
            if binary[idx] == '0':
                break
            idx += 1
        answer.append(n+2**(idx - (idx != 0)))
    
    return answer

def solution(numbers):
    answer = []
    for val in numbers:
        answer.append(((val ^ (val+1)) >> 2) +val +1)

    return answer

# 아래 솔루션이 어떻게해서 나왔는가
# 자신과 자신+1을 XOR 연산을 하게되면 바뀐 비트들이 1로 표시될 것이다.
# 짝수제외(짝수는 첫번째 비트가 무조건 0이기 때문에 1만 더해주면 된다.) 모든 자연수는 처음 0이 나오는 부분이 1이되고 바로 오른쪽 1이 0이되면 그게 문제 조건에 부합하는 숫자가 된다.
# 이진수 1은 1을 더하면 10이 되어 2개의 자릿수가 달라지기 때문에
# 오른쪽 시프트를 2번하게 되면, 1이 유지되는 부분이 나올것이다.
# 예를 들면 1001111에 1을 더하면 1010000이 되는데, XOR 연산을 하면 11111이 될것이고, 3번째 주석에 설명한것처럼 처음 0과 오른쪽 1만 달라지기 때문에 오른쪽 시프트를 2번하는것이다.
# 그러면 예시에서 11111을 오른쪽 시프트 2번하게 되면 111이 되고, 이는 1001111에서 처음으로 0이 등장하는 부분과 바로 오른쪽 1이 바뀌고 그 나머지 오른쪽 부분인 111이 나온다.
# 그러면 예시의 정답인 1010111을 분해해 보면 1010000 + 111이 될 것이고, 1010000은 기존값+1이고, 111은 앞서 시프트한 값이된다.
#이를 식으로 나타내면 아래코드와 같은 방식이 된다. 

# 프로그래머스 댓글 설명
#짝수를 이진수로 나타내면 무조건 끝의 자리는 0으로 끝나게 됩니다. 그러므로 짝수의 경우에는 비트 1~2개 차이가 나면 되니까, 해당 수에 1을 더하기만 하면 됩니다. 홀수의 경우에는 몇가지 수를 대입해서 확인해보시면 알겠지만, 결국에는 오른쪽에서부터 왼쪽으로 연속해서 1이 이어지다가 처음으로 0이 나온 위치를 파악하여, 해당 위치의 두칸 뒤의 자리까지 1로 채운 수 + 1만큼 더하면 됩니다. 예를 들어, 1001111이면, 1010111이 답이 되는데요.

# 어차피 여기서 원래의 값에 (원래의 값 + 1)을 XOR 연산을 하면, 최초로 0이 나온 자리까지 1이 연속으로 된 숫자만 나오게 됩니다(그 이상은 무조건 같은 수니까 다 씹히고, 이하의 수는 1이 한 번만 등장하니까 1이 되어서).

# 그런데 짝수는 무조건 오른쪽에서 첫번째 자리에서 처음으로 0이 나오니까 (val ^ (val + 1)) >> 2 값은 무조건 0으로 됩니다. 그러면 나머지 val + 1만 남게되어, 결국 제가 처음에 말한대로 짝수의 경우는 무조건 해당 수에 1을 더하기만 하는 규칙대로 나오게 됩니다.

# 홀수의 경우는 원래의 값에서 + 1 한 숫자인 val + 1에, 처음으로 0이 나온 위치-2 한만큼까지 1이 연속된 수를 더하기만 하면 되는데요. 아까의 예시로 보았을 때 1001111과 1010111을 XOR 연산을 하면 11111이 나오는데 >> 2를 하면 111이 됩니다(0이 오른쪽에서 5번째에 등장하는데, 2를 빼니까 3번째까지 1이 연속된 숫자인 111이 나오는 것). 방금 더한 과정을 식으로 나타내면 (val ^ (val + 1)) >> 2이 되는 것입니다.